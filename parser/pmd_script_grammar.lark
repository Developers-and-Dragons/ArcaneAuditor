?program: source_elements?

%import common.WS
%ignore WS

?source_elements: statement+

?statement: block
    | variable_statement
    | empty_statement
    | expression_statement
    | if_statement
    | iteration_statement
    | continue_statement
    | break_statement
    | return_statement
    | labelled_statement

?block: "{" statement_list? "}"

?statement_list: statement+

?variable_statement: VAR variable_declaration_list eos?
    | LET variable_declaration_list eos?
    | CONST variable_declaration_list eos?

?variable_declaration_list: variable_declaration ("," variable_declaration)*

?variable_declaration: IDENTIFIER initializer?

?initializer: "=" single_expression

?empty_statement: ";"

?expression_statement: expression_sequence

?if_statement: IF "(" expression_sequence ")" statement (ELSE statement)?

?iteration_statement: DO statement WHILE "(" expression_sequence ")" eos? -> do_statement
    | WHILE "(" expression_sequence ")" statement -> while_statement
    | FOR "(" expression_sequence? ";" expression_sequence? ";" expression_sequence? ")" statement -> for_statement
    | FOR "(" VAR variable_declaration_list ";" expression_sequence? ";" expression_sequence? ")" statement -> for_var_statement
    | FOR "(" LET variable_declaration_list ";" expression_sequence? ";" expression_sequence? ")" statement -> for_let_statement
    | FOR "(" CONST variable_declaration_list ";" expression_sequence? ";" expression_sequence? ")" statement -> for_const_statement
    | FOR "(" LET IDENTIFIER ":" expression_sequence ")" statement -> for_let_in_statement
    | FOR "(" VAR IDENTIFIER ":" expression_sequence ")" statement -> for_var_in_statement
    | FOR "(" CONST IDENTIFIER ":" expression_sequence ")" statement -> for_const_in_statement
    
?continue_statement: CONTINUE [IDENTIFIER] eos?

?break_statement: BREAK [IDENTIFIER] eos?

?return_statement: RETURN [single_expression] eos?

?labelled_statement: IDENTIFIER ":" statement

?formal_parameter_list: IDENTIFIER ("," IDENTIFIER)*

?function_body: source_elements?

?array_literal: "[" [element_list] ","? [elision] "]"

?element_list: elision? expression_sequence ("," elision? expression_sequence)*

?elision: ","+

?object_literal: "{" ":" "}" -> empty_object_literal
    | "{" property_name_and_value_list "}" -> object_literal

?property_name_and_value_list: property_assignment ("," property_assignment)*

?property_assignment: property_name ":" single_expression -> property_expression_assignment
    | "get" property_name "(" ")" "{" function_body "}" -> property_getter
    | "set" property_name "(" property_set_parameter_list ")" "{" function_body "}" -> property_setter
    
?property_name: STRING_LITERAL
    | IDENTIFIER
    | numeric_literal

?property_set_parameter_list: IDENTIFIER

?arguments: "(" [argument_list] ")"

?argument_list: single_expression ("," single_expression)*

?expression_sequence: single_expression ("," single_expression)*


// --- START: CORRECTED EXPRESSION HIERARCHY ---

// The main entry point for an expression, starting with the lowest precedence.
?single_expression: assignment_expression

// Precedence Level: Assignment (Right-associative)
?assignment_expression: ternary_expression
    | ternary_expression "=" expression_sequence -> assignment_expression
    | ternary_expression assignment_operator expression_sequence -> assignment_operator_expression

// Precedence Level: Ternary (Right-associative)
?ternary_expression: logical_or_expression ("?" assignment_expression ":" assignment_expression)?

// Precedence Level: Logical OR
?logical_or_expression: logical_and_expression ("||" logical_and_expression)*

// Precedence Level: Logical AND
?logical_and_expression: equality_expression ("&&" equality_expression)*

// Precedence Level: Equality
?equality_expression: relational_expression (("==" | "!=") relational_expression)*

// Precedence Level: Relational
?relational_expression: additive_expression ((">" | "<" | "<=" | ">=") additive_expression)*

// Precedence Level: Additive
?additive_expression: multiplicative_expression (("+" | "-") multiplicative_expression)*

// Precedence Level: Multiplicative
?multiplicative_expression: unary_expression (("*" | "/" | "%") unary_expression)*

// Precedence Level: Unary (Prefix)
?unary_expression: PLUS_PLUS unary_expression -> pre_increment_expression
    | MINUS_MINUS unary_expression -> pre_decrease_expression
    | PLUS unary_expression -> unary_plus_expression
    | MINUS unary_expression -> unary_minus_expression
    | NOT unary_expression -> not_expression
    | TYPEOF unary_expression -> typeof_expression
    | EMPTY unary_expression -> empty_expression
    | EMPTY "(" single_expression ")" -> empty_function_expression
    | postfix_expression

// Precedence Level: Postfix and Member Access
?postfix_expression: primary_expression
    | postfix_expression "[" expression_sequence "]" -> member_index_expression
    | postfix_expression "." identifier_name -> member_dot_expression
    | postfix_expression "?." identifier_name -> optional_member_dot_expression
    | postfix_expression arguments -> arguments_expression
    | postfix_expression PLUS_PLUS -> post_increment_expression
    | postfix_expression MINUS_MINUS -> post_decrease_expression

// Precedence Level: Primary (Highest)
// These are the fundamental building blocks of expressions.
?primary_expression: IDENTIFIER -> identifier_expression
    | literal -> literal_expression
    | array_literal -> array_literal_expression
    | object_literal -> object_literal_expression
    | "(" expression_sequence ")" -> parenthesized_expression
    | "(" expression_sequence "to" expression_sequence ")" -> range_expression
    | FUNCTION IDENTIFIER? "(" formal_parameter_list? ")" "{" function_body "}" -> function_expression
    | "(" [IDENTIFIER ("," IDENTIFIER)*] ")" "=>" single_expression -> arrow_function_expression
    | "(" [IDENTIFIER ("," IDENTIFIER)*] ")" "=>" "{" function_body "}" -> arrow_function_expression
    | IDENTIFIER "=>" single_expression -> arrow_function_expression
    | IDENTIFIER "=>" "{" function_body "}" -> arrow_function_expression

// --- END: CORRECTED EXPRESSION HIERARCHY ---


?assignment_operator: "*=" | "/=" | "%=" | "+=" | "-="

?literal: NULL_LITERAL | BOOLEAN_LITERAL | STRING_LITERAL | TEMPLATE_LITERAL | REGULAR_EXPRESSION_LITERAL | numeric_literal

?numeric_literal: DECIMAL_LITERAL | HEX_INTEGER_LITERAL | OCTAL_INTEGER_LITERAL

?identifier_name: IDENTIFIER | reserved_word

?reserved_word: keyword | future_reserved_word | NULL_LITERAL | BOOLEAN_LITERAL

?keyword: BREAK | DO | INSTANCEOF | TYPEOF | ELSE | VAR | RETURN | CONTINUE | FOR | WHILE | FUNCTION | IF | EMPTY
?future_reserved_word: CONST | LET

?eos: ";"

REGULAR_EXPRESSION_LITERAL: /\/[^\/\\r\\n]+\/[a-zA-Z$_]*/

NULL_LITERAL: "null"
BOOLEAN_LITERAL: "true" | "false"

DECIMAL_LITERAL: /(0|[1-9][0-9]*)\.[0-9]*([eE][+-]?[0-9]+)?|\.[0-9]+([eE][+-]?[0-9]+)?|(0|[1-9][0-9]*)([eE][+-]?[0-9]+)?/
HEX_INTEGER_LITERAL: /0[xX][0-9a-fA-F]+/
OCTAL_INTEGER_LITERAL: /0[0-7]+/

BREAK: "break"
DO: "do"
INSTANCEOF: "instanceof"
TYPEOF: "typeof"
ELSE: "else"
NEW: "new"
VAR: "var"
RETURN: "return"
CONTINUE: "continue"
FOR: "for"
WHILE: "while"
FUNCTION: "function"
IF: "if"
CONST: "const"
LET: "let"
EMPTY: "empty"
TO: "to"

IDENTIFIER: /[a-zA-Z_$][a-zA-Z0-9_$]*/
STRING_LITERAL: /"([^"\\\r\n]|\\[^\r\n]|\\\r?\n)*"|'([^'\\\r\n]|\\[^\r\n]|\\\r?\n)*'/
TEMPLATE_LITERAL: /`([^`\\\r\n]|\\[^\r\n]|\\\r?\n)*`/

// Punctuation and Operators
ASSIGN: "="
QUESTION_MARK: "?"
COLON: ":"
DOT: "."
OPTIONAL_DOT: "?."
LBRACE: "{"
RBRACE: "}"
PLUS_PLUS: "++"
MINUS_MINUS: "--"
PLUS: "+"
MINUS: "-"
NOT: "!"
MULTIPLY: "*"
DIVIDE: "/"
MODULUS: "%"
LESS_THAN: "<"
MORE_THAN: ">"
LESS_THAN_EQUALS: "<="
GREATER_THAN_EQUALS: ">="
EQUALS: "=="
NOT_EQUALS: "!="
AND: "&&"
OR: "||"
NULL_COALESCING: "??"
MULTIPLY_ASSIGN: "*="
DIVIDE_ASSIGN: "/="
MODULUS_ASSIGN: "%="
PLUS_ASSIGN: "+="
MINUS_ASSIGN: "-="
ARROW: "=>"

// Ignored tokens
%ignore /(\/\*.*?\*\/|\/\/[^\r\n]*|[\t\u000B\u000C\u0020\u00A0]+|[\r\n\u2028\u2029])+/
